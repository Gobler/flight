<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Flight by mikecao</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Flight</h1>
<p>An extensible micro-framework for PHP</p>
        <p class="view"><a href="https://github.com/mikecao/flight">View the Project on GitHub <small>mikecao/flight</small></a></p>
        <ul>
          <li><a href="https://github.com/mikecao/flight/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/mikecao/flight/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/mikecao/flight">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>What is Flight?</h1>

<p>Flight is a fast, simple, extensible framework for PHP.
Flight enables you to quickly and easily build RESTful web applications.</p>

<pre><code>require 'flight/Flight.php';

Flight::route('/', function(){
    echo 'hello world!';
});

Flight::start();
</code></pre>

<p><a href="http://flightphp.com/learn">Learn more</a></p>

<h1>Requirements</h1>

<p>Flight requires PHP 5.3 or greater. </p>

<h1>License</h1>

<p>Flight is released under the <a href="http://www.opensource.org/licenses/mit-license.php">MIT</a> license.</p>

<h1>Installation</h1>

<p>1. <a href="https://github.com/mikecao/flight/tarball/master">Download</a> and extract the Flight framework files to your web directory.</p>

<p>2. Configure your webserver.</p>

<p>For <em>Apache</em>, edit your .htaccess file with the following:</p>

<pre><code>RewriteEngine On
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d
RewriteRule ^(.*)$ index.php [QSA,L]
</code></pre>

<p>For <em>Nginx</em>, add the following to your server declaration:</p>

<pre><code>server {
    location / {
        try_files $uri $uri/ /index.php;
    }
}
</code></pre>

<p>3. Create your index.php file.</p>

<p>First include the framework.</p>

<pre><code>require 'flight/Flight.php';
</code></pre>

<p>Then define a route and assign a function to handle the request.</p>

<pre><code>Flight::route('/', function(){
    echo 'hello world!';
});
</code></pre>

<p>Finally, start the framework.</p>

<pre><code>Flight::start();
</code></pre>

<h1>Routing</h1>

<p>Routing in Flight is done by matching a URL pattern with a callback function.</p>

<pre><code>Flight::route('/', function(){
    echo 'hello world!';
});
</code></pre>

<p>The callback can be any object that is callable. So you can use a regular function:</p>

<pre><code>function hello(){
    echo 'hello world!';
}

Flight::route('/', 'hello');
</code></pre>

<p>Or a class method:</p>

<pre><code>class Greeting {
    public static function hello() {
        echo 'hello world!';
    }
}

Flight::route('/', array('Greeting','hello'));
</code></pre>

<p>Routes are matched in the order they are defined. The first route to match a request will be invoked.</p>

<h2>Method Routing</h2>

<p>By default, route patterns are matched against all request methods. You can respond to specific
methods by placing an identifier before the URL.</p>

<pre><code>Flight::route('GET /', function(){
    echo 'I received a GET request.';
});

Flight::route('POST /', function(){
    echo 'I received a POST request.';
});
</code></pre>

<p>You can also map multiple methods to a single callback by using a <code>|</code> delimiter:</p>

<pre><code>Flight::route('GET|POST /', function(){
    echo 'I received either a GET or a POST request.';
});
</code></pre>

<p>Method specific routes have precedence over global routes.</p>

<h2>Regular Expressions</h2>

<p>You can use regular expressions in your routes:</p>

<pre><code>Flight::route('/user/[0-9]+', function(){
    // This will match /user/1234
});
</code></pre>

<h2>Named Parameters</h2>

<p>You can specify named parameters in your routes which will be passed along to your callback function.</p>

<pre><code>Flight::route('/@name/@id', function($name, $id){
    echo "hello, $name ($id)!";
});
</code></pre>

<p>You can also include regular expressions with your named parameters by using the <code>:</code> delimiter:</p>

<pre><code>Flight::route('/@name/@id:[0-9]{3}', function($name, $id){
    // This will match /bob/123
    // But will not match /bob/12345
});
</code></pre>

<h2>Wildcards</h2>

<p>Matching is only done on individual URL segments. If you want to match multiple segments you can use the <code>*</code> wildcard.</p>

<pre><code>Flight::route('/blog/*', function(){
    // This will match /blog/2000/02/01
});
</code></pre>

<p>To route all requests to a single callback, you can do:</p>

<pre><code>Flight::route('*', function(){
    // Do something
});
</code></pre>

<h1>Extending</h1>

<p>Flight is designed to be an extensible framework. The framework comes with a set of default methods and components, but it allows you to map your own methods, register your own classes, or even override existing classes and methods.</p>

<h2>Mapping Methods</h2>

<p>To map your own custom method, you use the <code>map</code> function:</p>

<pre><code>// Map your method
Flight::map('hello', function($name){
    echo "hello $name!";
});

// Call your custom method
Flight::hello('Bob');
</code></pre>

<h2>Registering Classes</h2>

<p>To register your own class, you use the <code>register</code> function:</p>

<pre><code>// Register your class
Flight::register('user', 'User');

// Get an instance of your class
$user = Flight::user();
</code></pre>

<p>The register method also allows you to pass along parameters to your class constructor. So when you load your custom class, it will come pre-initialized. You can define the constructor parameters by passing in an additional array. Here's an example of loading a database connection:</p>

<pre><code>// Register class with constructor parameters
Flight::register('db', 'Database', array('localhost','mydb','user','pass'));

// Get an instance of your class
// This will create an object with the defined parameters
//
//     new Database('localhost', 'mydb', 'user', 'pass');
//
$db = Flight::db();
</code></pre>

<p>If you pass in an additional callback parameter, it will be executed immediately after class construction. This allows you to perform any set up procedures for your new object. The callback function takes one parameter, an instance of the new object.</p>

<pre><code>// The callback will be passed the object that was constructed
Flight::register('db', 'Database', array('localhost', 'mydb', 'user', 'pass'), function($db){
    $db-&gt;connect();
});
</code></pre>

<p>By default, every time you load your class you will get a shared instance.
To get a new instance of a class, simply pass in <code>false</code> as a parameter:</p>

<pre><code>// Shared instance of Database class
$shared = Flight::db();

// New instance of Database class
$new = Flight::db(false);
</code></pre>

<p>Keep in mind that mapped methods have precedence over registered classes. If you declare both
using the same name, only the mapped method will be invoked.</p>

<h1>Overriding</h1>

<p>Flight allows you to override its default functionality to suit your own needs, without having to modify any code.</p>

<p>For example, when Flight cannot match a URL to a route, it invokes the <code>notFound</code> method which sends a generic HTTP 404 response.
You can override this behavior by using the <code>map</code> method:</p>

<pre><code>Flight::map('notFound', function(){
    // Display custom 404 page
    include 'errors/404.html';
});
</code></pre>

<p>Flight also allows you to replace core components of the framework.
For example you can replace the default Router class with your own custom class:</p>

<pre><code>// Register your custom class
Flight::register('router', 'MyRouter');

// When Flight loads the Router instance, it will load your class
$myrouter = Flight::router();
</code></pre>

<p>Framework methods like <code>map</code> and <code>register</code> however cannot be overridden. You will get an error if you try to do so.</p>

<h1>Filtering</h1>

<p>Flight allows you to filter methods before and after they are called. There are no predefined hooks
you need to memorize. You can filter any of the default framework methods as well as any custom methods that
you've mapped.</p>

<p>A filter function looks like this:</p>

<pre><code>function(&amp;$params, &amp;$output) {
    // Filter code
}
</code></pre>

<p>Using the passed in variables you can manipulate the input parameters and/or the output.</p>

<p>You can have a filter run before a method by doing:</p>

<pre><code>Flight::before('start', function(&amp;$params, &amp;$output){
    // Do something
});
</code></pre>

<p>You can have a filter run after a method by doing:</p>

<pre><code>Flight::after('start', function(&amp;$params, &amp;$output){
    // Do something
});
</code></pre>

<p>You can add as many filters as you want to any method. They will be called in the order
that they are declared.</p>

<p>Here's an example of the filtering process:</p>

<pre><code>// Map a custom method
Flight::map('hello', function($name){
    return "Hello, $name!";
});

// Add a before filter
Flight::before('hello', function(&amp;$params, &amp;$output){
    // Manipulate the parameter
    $params[0] = 'Fred';
});

// Add an after filter
Flight::after('hello', function(&amp;$params, &amp;$output){
    // Manipulate the output
    $output .= " Have a nice day!";
}

// Invoke the custom method
echo Flight::hello('Bob');
</code></pre>

<p>This should display:</p>

<pre><code>Hello Fred! Have a nice day! 
</code></pre>

<p>If you have defined multiple filters, you can break the chain by returning <code>false</code> in any of your filter functions:</p>

<pre><code>Flight::before('start', function(&amp;$params, &amp;$output){
    echo 'one';
});

Flight::before('start', function(&amp;$params, &amp;$output){
    echo 'two';

    // This will end the chain
    return false;
});

// This will not get called
Flight::before('start', function(&amp;$params, &amp;$output){
    echo 'three';
});
</code></pre>

<p>Note, core methods such as <code>map</code> and <code>register</code> cannot be filtered because they are called
directly and not invoked dynamically.</p>

<h1>Variables</h1>

<p>Flight allows you to save variables so that they can be used anywhere in your application.</p>

<pre><code>// Save your variable
Flight::set('id', 123);

// Elsewhere in your application
$id = Flight::get('id');
</code></pre>

<p>To see if a variable has been set you can do:</p>

<pre><code>if (Flight::has('id')) {
    // Do something
}
</code></pre>

<p>You can clear a variable by doing:</p>

<pre><code>// Clears the id variable
Flight::clear('id');

// Clears all variables
Flight::clear();
</code></pre>

<p>Flight also uses variables for configuration purposes.</p>

<pre><code>Flight::set('flight.log_errors', true);
</code></pre>

<h1>Views</h1>

<p>Flight provides some basic templating functionality by default. To display a view template call the <code>render</code> method with the name of the template file and optional template data:</p>

<pre><code>Flight::render('hello.php', array('name', 'Bob'));
</code></pre>

<p>The template data you pass in is automatically injected into the template and can be reference like a local variable. Template files are simply PHP files. If the content of the <code>hello.php</code> template file is:</p>

<pre><code>Hello, '&lt;?php echo $name; ?&gt;'!
</code></pre>

<p>The output would be:</p>

<pre><code>Hello, Bob!
</code></pre>

<p>You can also manually set view variables by using the set method:</p>

<pre><code>Flight::view()-&gt;set('name', 'Bob');
</code></pre>

<p>The variable <code>name</code> is now available across all your views. So you can simply do:</p>

<pre><code>Flight::render('hello');
</code></pre>

<p>Note that when specifying the name of the template in the render method, you can leave out the .php extension.</p>

<p>By default Flight will look for a <code>views</code> directory for template files. You can set an alternate path for your templates by setting the following config:</p>

<pre><code>Flight::set('flight.views.path', '/path/to/views');
</code></pre>

<h2>Layouts</h2>

<p>It is common for websites to have a single layout template file with interchanging content. To render content to be used in a layout, you can pass in an optional parameter to the <code>render</code> method.</p>

<pre><code>Flight::render('header', array('heading' =&gt; 'Hello'), 'header_content');
Flight::render('body', array('message' =&gt; 'World'), 'body_content');
</code></pre>

<p>Your view will then have saved variables called <code>header_content</code> and <code>body_content</code>. You can then render your layout by doing:</p>

<pre><code>Flight::render('layout', array('title' =&gt; 'Home Page'));
</code></pre>

<p>If the template files looks like this:</p>

<p>header.php:</p>

<pre><code>&lt;h1&gt;&lt;?php echo $heading; ?&gt;&lt;/h1&gt;
</code></pre>

<p>body.php:</p>

<pre><code>&lt;div&gt;&lt;?php echo $body; ?&gt;&lt;/div&gt;
</code></pre>

<p>layout.php:</p>

<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;&lt;?php echo $title; ?&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;?php echo $header_content; ?&gt;
&lt;?php echo $body_content; ?&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>The output would be:</p>

<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Home Page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Hello&lt;/h1&gt;
&lt;div&gt;World&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h2>Custom Views</h2>

<p>Flight allows you to swap out the default view engine simply by registering your own view class.
Here's how you would use the <a href="http://www.smarty.net/">Smarty</a> template engine for your views:</p>

<pre><code>// Load Smarty library
require './Smarty/libs/Smarty.class.php';

// Register Smarty as the view class
// Also pass a callback function to configure Smarty on load
Flight::register('view', 'Smarty', array(), function($smarty){
    $smarty-&gt;template_dir = './templates/';
    $smarty-&gt;compile_dir = './templates_c/';
    $smarty-&gt;config_dir = './config/';
    $smarty-&gt;cache_dir = './cache/';
});

// Assign template data
Flight::view()-&gt;assign('name', 'Bob');

// Display the template
Flight::view()-&gt;display('hello.tpl');
</code></pre>

<p>For completeness, you should also override Flight's default render method:</p>

<pre><code>Flight::map('render', function($template, $data){
    Flight::view()-&gt;assign($data);
    Flight::view()-&gt;display($template);
});
</code></pre>

<h1>Error Handling</h1>

<h2>Errors and Exceptions</h2>

<p>All errors and exceptions are caught by Flight and passed to the <code>error</code> method.
The default behavior is to send a generic HTTP <code>500 Internal Server Error</code> response with some error information.
You can override this behavior for your own needs:</p>

<pre><code>Flight::map('error', function(){
    // Handle error
});
</code></pre>

<p>By default errors are not logged to the web server. You can enable this by changing the config:</p>

<pre><code>Flight::set('flight.log_errors', true);
</code></pre>

<h2>Not Found</h2>

<p>When a URL can't be found, Flight calls the <code>notFound</code> method. The default behavior is to
send an HTTP <code>404 Not Found</code> response with a simple message. You can override this behavior for your own needs:</p>

<pre><code>Flight::map('notFound', function(){
    // Handle not found
});
</code></pre>

<h1>Redirects</h1>

<p>You can redirect the current request by using the <code>redirect</code> method and passing in a new URL:</p>

<pre><code>Flight::redirect('/new/location');
</code></pre>

<h1>Requests</h1>

<p>Flight encapsulates the HTTP request into a single object, which can be accessed by doing:</p>

<pre><code>$request = Flight::request();
</code></pre>

<p>The request object provides the following properties:</p>

<pre><code>url - The URL being requested
base - The parent subdirectory of the URL
method - The request method (GET, POST, PUT, DELETE)
referrer - The referrer URL
ip - IP address of the client
ajax - Whether the request is an AJAX request
scheme - The server protocol (http, https)
user_agent - Browser information
body - Raw data from the request body
type - The content type
length - The content length
query - Query string parameters
data - Post parameters
cookies - Cookie parameters
files - Uploaded files
</code></pre>

<p>You can access the <code>query</code>, <code>data</code>, <code>cookies</code>, and <code>files</code> properties as arrays or objects.
So, to get a query string parameter, you can do:</p>

<pre><code>$id = Flight::request()-&gt;query['id'];
</code></pre>

<p>Or you can do:</p>

<pre><code>$id = Flight::request()-&gt;query-&gt;id;
</code></pre>

<h1>HTTP Caching</h1>

<p>Flight provides built-in support for HTTP level caching. If the caching condition is met,
Flight will return an HTTP <code>304 Not Modified</code> response. The next time the client requests the same resource,
they will be prompted to use their locally cached version.</p>

<h2>Last-Modified</h2>

<p>You can use the <code>lastModified</code> method and pass in a UNIX timestamp to set the date and time a page was last modified.
The client will continue to use their cache until the last modified value is changed.</p>

<pre><code>Flight::route('/news', function(){
    Flight::lastModified(1234567890);
    echo 'This content will be cached.';
});
</code></pre>

<h2>ETag</h2>

<p>ETag caching is similar to Last-Modified, except you can specify any id you want for the resource:</p>

<pre><code>Flight::route('/news', function(){
    Flight::etag('my-unique-id');
    echo 'This content will be cached.';
});
</code></pre>

<p>Keep in mind that calling either <code>lastModified</code> or <code>etag</code> will both set and check the cache value.
If the cache value is the same between requests, Flight will immediately send an HTTP 304 response and stop
processing.</p>

<h1>Stopping</h1>

<p>You can stop the framework at any point by calling the <code>halt</code> method:</p>

<pre><code>Flight::halt();
</code></pre>

<p>You can also specify an optional HTTP status code and message:</p>

<pre><code>Flight::halt(200, 'Be right back...');
</code></pre>

<p>Calling <code>halt</code> will discard any response content up to that point.
If you want to stop the framework and output the current response, use the <code>stop</code> method:</p>

<pre><code>Flight::stop();
</code></pre>

<h1>Framework Methods</h1>

<p>Flight is designed to be easy to use and understand. The following is the complete set of methods
for the framework. It consists of core methods, which are regular static methods, and
extensible methods, which can be filtered or overridden.</p>

<h2>Core Methods</h2>

<pre><code>Flight::map($name, $callback) - Creates a custom framework method.

Flight::register($name, $class, [$params], [$callback]) - Registers a class to a framework method.

Flight::before($name, $callback) - Adds a filter before a framework method.

Flight::after($name, $callback) - Adds a filter after a framework method.

Flight::path($path) - Adds a path for autoloading classes.

Flight::get($key) - Gets a variable.

Flight::set($key, $value) - Sets a variable.

Flight::has($key) - Checks if a variable is set.

Flight::clear([$key]) - Clears a variable.
</code></pre>

<h2>Extensible Methods</h2>

<pre><code>Flight::start() - Starts the framework.

Flight::stop() - Stops the framework and sends a response.

Flight::halt([$code], [$message]) - Stop the framework with an optional status code and message.

Flight::route($pattern, $callback) - Maps a URL pattern to a callback.

Flight::redirect($url, [$code]) - Redirects to another URL.

Flight::render($file, [$data], [$key]) - Renders a template file.

Flight::error($exception) - Sends an HTTP 500 response.

Flight::notFound() - Sends an HTTP 400 response.

Flight::etag($id, [$type]) - Performs ETag HTTP caching.

Flight::lastModified($time) - Performs last modified HTTP caching.

Flight::json($data) - Sends a JSON response.
</code></pre>

<p>Any custom methods added with <code>map</code> and <code>register</code> can also be filtered.</p>
      </section>
    </div>
    <footer>
      <p>Project maintained by <a href="https://github.com/mikecao">mikecao</a></p>
      <p>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></p>
    </footer>
    <!--[if !IE]><script>fixScale(document);</script><!--<![endif]-->
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-101933-10");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>