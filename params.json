{"name":"Flight","body":"# What is Flight?\r\n\r\nFlight is a fast, simple, extensible framework for PHP.\r\nFlight enables you to quickly and easily build RESTful web applications.\r\n\r\n    require 'flight/Flight.php';\r\n\r\n    Flight::route('/', function(){\r\n        echo 'hello world!';\r\n    });\r\n\r\n    Flight::start();\r\n\r\n[Learn more](http://flightphp.com/learn)\r\n\r\n# Requirements\r\n\r\nFlight requires PHP 5.3 or greater. \r\n\r\n# License\r\n\r\nFlight is released under the [MIT](http://www.opensource.org/licenses/mit-license.php) license.\r\n\r\n# Installation\r\n\r\n1\\. [Download](https://github.com/mikecao/flight/tarball/master) and extract the Flight framework files to your web directory.\r\n\r\n2\\. Configure your webserver.\r\n\r\nFor *Apache*, edit your .htaccess file with the following:\r\n\r\n    RewriteEngine On\r\n    RewriteCond %{REQUEST_FILENAME} !-f\r\n    RewriteCond %{REQUEST_FILENAME} !-d\r\n    RewriteRule ^(.*)$ index.php [QSA,L]\r\n\r\nFor *Nginx*, add the following to your server declaration:\r\n\r\n    server {\r\n        location / {\r\n            try_files $uri $uri/ /index.php;\r\n        }\r\n    }\r\n\r\n3\\. Create your index.php file.\r\n\r\nFirst include the framework.\r\n\r\n    require 'flight/Flight.php';\r\n\r\nThen define a route and assign a function to handle the request.\r\n\r\n    Flight::route('/', function(){\r\n        echo 'hello world!';\r\n    });\r\n\r\nFinally, start the framework.\r\n\r\n    Flight::start();\r\n\r\n# Routing \r\n\r\nRouting in Flight is done by matching a URL pattern with a callback function.\r\n\r\n    Flight::route('/', function(){\r\n        echo 'hello world!';\r\n    });\r\n\r\nThe callback can be any object that is callable. So you can use a regular function:\r\n\r\n    function hello(){\r\n        echo 'hello world!';\r\n    }\r\n\r\n    Flight::route('/', 'hello');\r\n\r\nOr a class method:\r\n\r\n    class Greeting {\r\n        public static function hello() {\r\n            echo 'hello world!';\r\n        }\r\n    }\r\n\r\n    Flight::route('/', array('Greeting','hello'));\r\n\r\nRoutes are matched in the order they are defined. The first route to match a request will be invoked.\r\n\r\n## Method Routing\r\n\r\nBy default, route patterns are matched against all request methods. You can respond to specific\r\nmethods by placing an identifier before the URL.\r\n\r\n    Flight::route('GET /', function(){\r\n        echo 'I received a GET request.';\r\n    });\r\n\r\n    Flight::route('POST /', function(){\r\n        echo 'I received a POST request.';\r\n    });\r\n\r\nYou can also map multiple methods to a single callback by using a `|` delimiter:\r\n\r\n    Flight::route('GET|POST /', function(){\r\n        echo 'I received either a GET or a POST request.';\r\n    });\r\n\r\nMethod specific routes have precedence over global routes.\r\n\r\n## Regular Expressions\r\n\r\nYou can use regular expressions in your routes:\r\n\r\n    Flight::route('/user/[0-9]+', function(){\r\n        // This will match /user/1234\r\n    });\r\n\r\n## Named Parameters\r\n\r\nYou can specify named parameters in your routes which will be passed along to your callback function.\r\n\r\n    Flight::route('/@name/@id', function($name, $id){\r\n        echo \"hello, $name ($id)!\";\r\n    });\r\n\r\nYou can also include regular expressions with your named parameters by using the `:` delimiter:\r\n\r\n    Flight::route('/@name/@id:[0-9]{3}', function($name, $id){\r\n        // This will match /bob/123\r\n        // But will not match /bob/12345\r\n    });\r\n\r\n## Wildcards\r\n\r\nMatching is only done on individual URL segments. If you want to match multiple segments you can use the `*` wildcard.\r\n\r\n    Flight::route('/blog/*', function(){\r\n        // This will match /blog/2000/02/01\r\n    });\r\n\r\nTo route all requests to a single callback, you can do:\r\n\r\n    Flight::route('*', function(){\r\n        // Do something\r\n    });\r\n\r\n# Extending\r\n\r\nFlight is designed to be an extensible framework. The framework comes with a set of default methods and components, but it allows you to map your own methods, register your own classes, or even override existing classes and methods.\r\n\r\n## Mapping Methods\r\n\r\nTo map your own custom method, you use the `map` function:\r\n\r\n    // Map your method\r\n    Flight::map('hello', function($name){\r\n        echo \"hello $name!\";\r\n    });\r\n\r\n    // Call your custom method\r\n    Flight::hello('Bob');\r\n\r\n## Registering Classes\r\n\r\nTo register your own class, you use the `register` function:\r\n\r\n    // Register your class\r\n    Flight::register('user', 'User');\r\n\r\n    // Get an instance of your class\r\n    $user = Flight::user();\r\n\r\nThe register method also allows you to pass along parameters to your class constructor. So when you load your custom class, it will come pre-initialized. You can define the constructor parameters by passing in an additional array. Here's an example of loading a database connection:\r\n\r\n    // Register class with constructor parameters\r\n    Flight::register('db', 'Database', array('localhost','mydb','user','pass'));\r\n\r\n    // Get an instance of your class\r\n    // This will create an object with the defined parameters\r\n    //\r\n    //     new Database('localhost', 'mydb', 'user', 'pass');\r\n    //\r\n    $db = Flight::db();\r\n\r\nIf you pass in an additional callback parameter, it will be executed immediately after class construction. This allows you to perform any set up procedures for your new object. The callback function takes one parameter, an instance of the new object.\r\n\r\n    // The callback will be passed the object that was constructed\r\n    Flight::register('db', 'Database', array('localhost', 'mydb', 'user', 'pass'), function($db){\r\n        $db->connect();\r\n    });\r\n\r\nBy default, every time you load your class you will get a shared instance.\r\nTo get a new instance of a class, simply pass in `false` as a parameter:\r\n\r\n    // Shared instance of Database class\r\n    $shared = Flight::db();\r\n\r\n    // New instance of Database class\r\n    $new = Flight::db(false);\r\n\r\nKeep in mind that mapped methods have precedence over registered classes. If you declare both\r\nusing the same name, only the mapped method will be invoked.\r\n\r\n# Overriding\r\n\r\nFlight allows you to override its default functionality to suit your own needs, without having to modify any code.\r\n\r\nFor example, when Flight cannot match a URL to a route, it invokes the `notFound` method which sends a generic HTTP 404 response.\r\nYou can override this behavior by using the `map` method:\r\n\r\n    Flight::map('notFound', function(){\r\n        // Display custom 404 page\r\n        include 'errors/404.html';\r\n    });\r\n\r\nFlight also allows you to replace core components of the framework.\r\nFor example you can replace the default Router class with your own custom class:\r\n\r\n    // Register your custom class\r\n    Flight::register('router', 'MyRouter');\r\n\r\n    // When Flight loads the Router instance, it will load your class\r\n    $myrouter = Flight::router();\r\n\r\nFramework methods like `map` and `register` however cannot be overridden. You will get an error if you try to do so.\r\n\r\n# Filtering\r\n\r\nFlight allows you to filter methods before and after they are called. There are no predefined hooks\r\nyou need to memorize. You can filter any of the default framework methods as well as any custom methods that\r\nyou've mapped.\r\n\r\nA filter function looks like this:\r\n\r\n    function(&$params, &$output) {\r\n        // Filter code\r\n    }\r\n\r\nUsing the passed in variables you can manipulate the input parameters and/or the output.\r\n\r\nYou can have a filter run before a method by doing:\r\n\r\n    Flight::before('start', function(&$params, &$output){\r\n        // Do something\r\n    });\r\n\r\nYou can have a filter run after a method by doing:\r\n\r\n    Flight::after('start', function(&$params, &$output){\r\n        // Do something\r\n    });\r\n\r\nYou can add as many filters as you want to any method. They will be called in the order\r\nthat they are declared.\r\n\r\nHere's an example of the filtering process:\r\n\r\n    // Map a custom method\r\n    Flight::map('hello', function($name){\r\n        return \"Hello, $name!\";\r\n    });\r\n\r\n    // Add a before filter\r\n    Flight::before('hello', function(&$params, &$output){\r\n        // Manipulate the parameter\r\n        $params[0] = 'Fred';\r\n    });\r\n\r\n    // Add an after filter\r\n    Flight::after('hello', function(&$params, &$output){\r\n        // Manipulate the output\r\n        $output .= \" Have a nice day!\";\r\n    }\r\n\r\n    // Invoke the custom method\r\n    echo Flight::hello('Bob');\r\n\r\nThis should display:\r\n\r\n    Hello Fred! Have a nice day! \r\n\r\nIf you have defined multiple filters, you can break the chain by returning `false` in any of your filter functions:\r\n\r\n    Flight::before('start', function(&$params, &$output){\r\n        echo 'one';\r\n    });\r\n\r\n    Flight::before('start', function(&$params, &$output){\r\n        echo 'two';\r\n\r\n        // This will end the chain\r\n        return false;\r\n    });\r\n\r\n    // This will not get called\r\n    Flight::before('start', function(&$params, &$output){\r\n        echo 'three';\r\n    });\r\n\r\nNote, core methods such as `map` and `register` cannot be filtered because they are called\r\ndirectly and not invoked dynamically.\r\n\r\n# Variables\r\n\r\nFlight allows you to save variables so that they can be used anywhere in your application.\r\n\r\n    // Save your variable\r\n    Flight::set('id', 123);\r\n\r\n    // Elsewhere in your application\r\n    $id = Flight::get('id');\r\n\r\nTo see if a variable has been set you can do:\r\n\r\n    if (Flight::has('id')) {\r\n        // Do something\r\n    }\r\n\r\nYou can clear a variable by doing:\r\n\r\n    // Clears the id variable\r\n    Flight::clear('id');\r\n\r\n    // Clears all variables\r\n    Flight::clear();\r\n\r\nFlight also uses variables for configuration purposes.\r\n\r\n    Flight::set('flight.log_errors', true);\r\n\r\n# Views \r\n\r\nFlight provides some basic templating functionality by default. To display a view template call the `render` method with the name of the template file and optional template data:\r\n\r\n    Flight::render('hello.php', array('name', 'Bob'));\r\n\r\nThe template data you pass in is automatically injected into the template and can be reference like a local variable. Template files are simply PHP files. If the content of the `hello.php` template file is:\r\n\r\n    Hello, '<?php echo $name; ?>'!\r\n\r\nThe output would be:\r\n\r\n    Hello, Bob!\r\n\r\nYou can also manually set view variables by using the set method:\r\n\r\n    Flight::view()->set('name', 'Bob');\r\n\r\nThe variable `name` is now available across all your views. So you can simply do:\r\n\r\n    Flight::render('hello');\r\n\r\nNote that when specifying the name of the template in the render method, you can leave out the .php extension.\r\n\r\nBy default Flight will look for a `views` directory for template files. You can set an alternate path for your templates by setting the following config:\r\n\r\n    Flight::set('flight.views.path', '/path/to/views');\r\n\r\n## Layouts\r\n\r\nIt is common for websites to have a single layout template file with interchanging content. To render content to be used in a layout, you can pass in an optional parameter to the `render` method.\r\n\r\n    Flight::render('header', array('heading' => 'Hello'), 'header_content');\r\n    Flight::render('body', array('message' => 'World'), 'body_content');\r\n\r\nYour view will then have saved variables called `header_content` and `body_content`. You can then render your layout by doing:\r\n\r\n    Flight::render('layout', array('title' => 'Home Page'));\r\n\r\nIf the template files looks like this:\r\n\r\nheader.php:\r\n\r\n    <h1><?php echo $heading; ?></h1>\r\n\r\nbody.php:\r\n\r\n    <div><?php echo $body; ?></div>\r\n\r\nlayout.php:\r\n\r\n    <html>\r\n    <head>\r\n    <title><?php echo $title; ?></title>\r\n    </head>\r\n    <body>\r\n    <?php echo $header_content; ?>\r\n    <?php echo $body_content; ?>\r\n    </body>\r\n    </html>\r\n\r\nThe output would be:\r\n\r\n    <html>\r\n    <head>\r\n    <title>Home Page</title>\r\n    </head>\r\n    <body>\r\n    <h1>Hello</h1>\r\n    <div>World</div>\r\n    </body>\r\n    </html>\r\n\r\n## Custom Views\r\n\r\nFlight allows you to swap out the default view engine simply by registering your own view class.\r\nHere's how you would use the [Smarty](http://www.smarty.net/) template engine for your views:\r\n\r\n    // Load Smarty library\r\n    require './Smarty/libs/Smarty.class.php';\r\n\r\n    // Register Smarty as the view class\r\n    // Also pass a callback function to configure Smarty on load\r\n    Flight::register('view', 'Smarty', array(), function($smarty){\r\n        $smarty->template_dir = './templates/';\r\n        $smarty->compile_dir = './templates_c/';\r\n        $smarty->config_dir = './config/';\r\n        $smarty->cache_dir = './cache/';\r\n    });\r\n\r\n    // Assign template data\r\n    Flight::view()->assign('name', 'Bob');\r\n\r\n    // Display the template\r\n    Flight::view()->display('hello.tpl');\r\n\r\nFor completeness, you should also override Flight's default render method:\r\n\r\n    Flight::map('render', function($template, $data){\r\n        Flight::view()->assign($data);\r\n        Flight::view()->display($template);\r\n    });\r\n\r\n# Error Handling \r\n\r\n## Errors and Exceptions\r\n\r\nAll errors and exceptions are caught by Flight and passed to the `error` method.\r\nThe default behavior is to send a generic HTTP `500 Internal Server Error` response with some error information.\r\nYou can override this behavior for your own needs:\r\n\r\n    Flight::map('error', function(){\r\n        // Handle error\r\n    });\r\n\r\nBy default errors are not logged to the web server. You can enable this by changing the config:\r\n\r\n    Flight::set('flight.log_errors', true);\r\n\r\n## Not Found\r\n\r\nWhen a URL can't be found, Flight calls the `notFound` method. The default behavior is to\r\nsend an HTTP `404 Not Found` response with a simple message. You can override this behavior for your own needs:\r\n\r\n    Flight::map('notFound', function(){\r\n        // Handle not found\r\n    });\r\n\r\n# Redirects \r\n\r\nYou can redirect the current request by using the `redirect` method and passing in a new URL:\r\n\r\n    Flight::redirect('/new/location');\r\n\r\n# Requests\r\n\r\nFlight encapsulates the HTTP request into a single object, which can be accessed by doing:\r\n\r\n    $request = Flight::request();\r\n\r\nThe request object provides the following properties:\r\n\r\n    url - The URL being requested\r\n    base - The parent subdirectory of the URL\r\n    method - The request method (GET, POST, PUT, DELETE)\r\n    referrer - The referrer URL\r\n    ip - IP address of the client\r\n    ajax - Whether the request is an AJAX request\r\n    scheme - The server protocol (http, https)\r\n    user_agent - Browser information\r\n    body - Raw data from the request body\r\n    type - The content type\r\n    length - The content length\r\n    query - Query string parameters\r\n    data - Post parameters\r\n    cookies - Cookie parameters\r\n    files - Uploaded files\r\n\r\nYou can access the `query`, `data`, `cookies`, and `files` properties as arrays or objects.\r\nSo, to get a query string parameter, you can do:\r\n\r\n    $id = Flight::request()->query['id'];\r\n\r\nOr you can do:\r\n\r\n    $id = Flight::request()->query->id;\r\n\r\n\r\n# HTTP Caching \r\n\r\nFlight provides built-in support for HTTP level caching. If the caching condition is met,\r\nFlight will return an HTTP `304 Not Modified` response. The next time the client requests the same resource,\r\nthey will be prompted to use their locally cached version.\r\n\r\n## Last-Modified\r\n\r\nYou can use the `lastModified` method and pass in a UNIX timestamp to set the date and time a page was last modified.\r\nThe client will continue to use their cache until the last modified value is changed.\r\n\r\n    Flight::route('/news', function(){\r\n        Flight::lastModified(1234567890);\r\n        echo 'This content will be cached.';\r\n    });\r\n\r\n## ETag\r\n\r\nETag caching is similar to Last-Modified, except you can specify any id you want for the resource:\r\n\r\n    Flight::route('/news', function(){\r\n        Flight::etag('my-unique-id');\r\n        echo 'This content will be cached.';\r\n    });\r\n\r\nKeep in mind that calling either `lastModified` or `etag` will both set and check the cache value.\r\nIf the cache value is the same between requests, Flight will immediately send an HTTP 304 response and stop\r\nprocessing.\r\n\r\n# Stopping \r\n\r\nYou can stop the framework at any point by calling the `halt` method:\r\n\r\n    Flight::halt();\r\n\r\nYou can also specify an optional HTTP status code and message:\r\n\r\n    Flight::halt(200, 'Be right back...');\r\n\r\nCalling `halt` will discard any response content up to that point.\r\nIf you want to stop the framework and output the current response, use the `stop` method:\r\n\r\n    Flight::stop();\r\n\r\n# Framework Methods\r\n\r\nFlight is designed to be easy to use and understand. The following is the complete set of methods\r\nfor the framework. It consists of core methods, which are regular static methods, and\r\nextensible methods, which can be filtered or overridden.\r\n\r\n## Core Methods\r\n\r\n    Flight::map($name, $callback) - Creates a custom framework method.\r\n\r\n    Flight::register($name, $class, [$params], [$callback]) - Registers a class to a framework method.\r\n\r\n    Flight::before($name, $callback) - Adds a filter before a framework method.\r\n\r\n    Flight::after($name, $callback) - Adds a filter after a framework method.\r\n\r\n    Flight::path($path) - Adds a path for autoloading classes.\r\n\r\n    Flight::get($key) - Gets a variable.\r\n\r\n    Flight::set($key, $value) - Sets a variable.\r\n\r\n    Flight::has($key) - Checks if a variable is set.\r\n\r\n    Flight::clear([$key]) - Clears a variable.\r\n\r\n## Extensible Methods\r\n\r\n    Flight::start() - Starts the framework.\r\n\r\n    Flight::stop() - Stops the framework and sends a response.\r\n\r\n    Flight::halt([$code], [$message]) - Stop the framework with an optional status code and message.\r\n\r\n    Flight::route($pattern, $callback) - Maps a URL pattern to a callback.\r\n\r\n    Flight::redirect($url, [$code]) - Redirects to another URL.\r\n\r\n    Flight::render($file, [$data], [$key]) - Renders a template file.\r\n\r\n    Flight::error($exception) - Sends an HTTP 500 response.\r\n\r\n    Flight::notFound() - Sends an HTTP 400 response.\r\n\r\n    Flight::etag($id, [$type]) - Performs ETag HTTP caching.\r\n\r\n    Flight::lastModified($time) - Performs last modified HTTP caching.\r\n\r\n    Flight::json($data) - Sends a JSON response.\r\n\r\nAny custom methods added with `map` and `register` can also be filtered.\r\n","tagline":"An extensible micro-framework for PHP","google":"UA-101933-10","note":"Don't delete this file! It's used internally to help with page regeneration."}